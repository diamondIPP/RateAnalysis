import copy
import collections
import os
from array import array
import numpy as np
import pickle
import json
import ConfigParser

from AbstractClasses.Elementary import Elementary
import ROOT
from ROOT import TCut
from numpy import mean


class Cut(Elementary):
    """
    A cut contains all cut settings which corresponds to a single diamond
    in a single run. Thus, an Analysis object holds two Cut instances, one
    for each diamond. The default configuration is loaded from the Analysis
    config file, whereas the individual cut settings are loaded from a JSON
    file located at Configuration/Individual_Configs. The JSON
    files are generated by the Analysis method SetIndividualCuts().
    """

    def __init__(self, parent_analysis, channel, verbose=True):
        # print "init cut"
        self.analysis = parent_analysis
        self.channel = channel
        self._checklist = {"RemoveBeamInterruptions": False,
                           "GenerateCutString": False}

        # readable cut types
        self.userCutTypes = {"IndividualChCut": "",
                             "EventRange": "Evts.50k-1433k",
                             "ExcludeFirst": "50k+",
                             "noPulser": "!pulser",
                             "notSaturated": "!saturated",
                             "noBeamInter": "!BeamInter.",
                             "FFT": "",
                             "Tracks": "Track",
                             "peakPos_high": "peakPos<250",
                             "spread_low": "spread>20",
                             "absMedian_high": "|median|<10",
                             "pedestalsigma": "PedSigma5"}
        # default cut Types
        self.cut_types = {"IndividualChCut": "",
                          "EventRange": [],     # [1234, 123456]
                          "ExcludeFirst": 0,    # 50000 events
                          "noPulser": 1,        # 1: nopulser, 0: pulser, -1: no cut
                          "notSaturated": True,
                          "noBeamInter": True,
                          "FFT": False,
                          "Tracks": True,
                          "peakPos_high": -1,
                          "spread_low": -1,
                          "absMedian_high": -1,
                          "pedestalsigma": -1
                          }

        self.cut_strings = {'beam_interruptions': TCut('beam_interruptions', '')}
        self.__cutstring_settings = None

        # variables
        self.jumps = None
        self.jump_ranges = None
        self.excludefirst = 0
        self.cut = ""
        Elementary.__init__(self, verbose=verbose)
        self.GenerateCutString()

    def LoadConfig(self):
        # print "config"
        configfile = "Configuration/AnalysisConfig_" + self.TESTCAMPAIGN + ".cfg"
        parser = ConfigParser.ConfigParser()
        parser.read(configfile)

        # beam interruptions folder:
        self.beaminterruptions_folder = parser.get("CUT", "beaminterruptions_folder")

        # individual additional cuts:
        self.cut = parser.get("CUT", "cut" + str(self.channel)) if not parser.get("CUT", "cut" + str(self.channel)) in ["-1", "", "True", "False"] else ""
        self.cut_types["IndividualChCut"] = copy.deepcopy(self.cut)
        self.userCutTypes["IndividualChCut"] = copy.deepcopy(self.cut)

        # pulser cut:
        self.cut_types["noPulser"] = parser.getint("CUT", "notPulser")

        # exclude first: (negative: time in minutes, positive: nevents)
        excludefirst = parser.getint("CUT", "excludefirst")
        self.SetExcludeFirst(excludefirst)

        # event range cuts:
        EventRange_min = parser.getint("CUT", "EventRange_min")
        EventRange_max = parser.getint("CUT", "EventRange_max")
        self.SetEventRange(min_event=EventRange_min, max_event=EventRange_max)

        # not saturated cut:
        self.cut_types["notSaturated"] = parser.getboolean("CUT", "notSaturated")

        # not beam interruption cut:
        self.cut_types["noBeamInter"] = parser.getboolean("CUT", "noBeamInter")
        self.excludeBeforeJump = parser.getint("CUT", "excludeBeforeJump")
        self.excludeAfterJump = parser.getint("CUT", "excludeAfterJump")

        # FFT cut:
        self.cut_types["FFT"] = parser.getboolean("CUT", "FFT")

        # has tracks cut:
        self.cut_types["Tracks"] = parser.getboolean("CUT", "hasTracks")

        # peakPos_high cut:
        high = parser.getint("CUT", "peakPos_high")
        self._SetPeakPos_high(high=high)

        # spread_low cut:
        low = parser.getint("CUT", "spread_low")
        self._SetSpread_low(low=low)

        # spread_low cut:
        high = parser.getint("CUT", "absMedian_high")
        self._SetAbsMedian_high(high=high)

        # pedestal sigma cut:
        sigma = parser.getint("CUT", "pedestalsigma")
        self._SetPedestalSigma(sigma=sigma)

        # .. and Load individual cuts, if they exists:
        self.LoadIndividualCuts()

    def LoadIndividualCuts(self):
        path = "Configuration/Individual_Configs/"
        filename = "{testcp}_Run{run}.json".format(testcp=self.TESTCAMPAIGN, run=self.analysis.run.run_number)
        filepath = path + filename
        if os.path.exists(filepath):
            print "Loading run-specific config file:"
            print "\t" + filepath

            f = open(filepath, "r")
            self.individualCuts = json.load(f)
            f.close()
            print "INDIVIDUAL Cuts:"
            print self.individualCuts
            ch = self.channel
            if self.individualCuts[str(ch)]["EventRange"] is not None:
                self.SetEventRange(min_event=int(self.individualCuts[str(ch)]["EventRange"][0]), max_event=int(self.individualCuts[str(ch)]["EventRange"][1]))
            elif self.individualCuts[str(ch)]["ExcludeFirst"] is not None:
                self.SetExcludeFirst(n=int(self.individualCuts[str(ch)]["ExcludeFirst"]))

            if self.individualCuts[str(ch)]["peakPos_high"] is not None:
                self._SetPeakPos_high(high=int(self.individualCuts[str(ch)]["peakPos_high"]))

            if self.individualCuts[str(ch)]["spread_low"] is not None:
                self._SetSpread_low(low=int(self.individualCuts[str(ch)]["spread_low"]))

            if self.individualCuts[str(ch)]["absMedian_high"] is not None:
                self._SetAbsMedian_high(high=int(self.individualCuts[str(ch)]["absMedian_high"]))

    def SetEventRange(self, min_event=0, max_event=0):
        """
        Sets the event range cut. If the arguments are negative, they are interpreted as time in minutes. Therefore, e.g. 
        SetEventRange(-10, 700000) means that only events are considered, which fulfill: >10 minutes after run start event number < 700000
        :param min_event:
        :param max_event:
        :return:
        """
        if min_event != 0 and max_event != 0:
            if min_event < 0:
                min_event = self.analysis.GetEventAtTime(time_sec=(-1) * min_event * 60)
            if max_event < 0:
                max_event = self.analysis.GetEventAtTime(time_sec=(-1) * max_event * 60)
            self.cut_types["EventRange"] = [min_event, max_event]
        elif min_event != 0:
            if min_event < 0:
                min_event = self.analysis.GetEventAtTime(time_sec=(-1) * min_event * 60)
            maxevent = self.analysis.GetEventAtTime(-1)
            self.cut_types["EventRange"] = [min_event, maxevent]
        elif max_event != 0:
            if max_event < 0:
                max_event = self.analysis.GetEventAtTime(time_sec=(-1) * max_event * 60)
            self.cut_types["EventRange"] = [self.excludefirst, max_event]
        else:
            self.cut_types["EventRange"] = []

    def GetIncludedEvents(self, maxevent=None):
        """
        Returns a list of event numbers, which are not excluded by the
        following cuts (i.e. event cuts):
            - excludeFirst cut
            - event-range cut
            - beam-interruptions cut
        :return: list of included event numbers
        """
        minevent = self.GetMinEvent()
        if maxevent is None:
            maxevent = self.GetMaxEvent()

        excluded = [i for i in np.arange(0, minevent)]  # first events
        if self.cut_types["noBeamInter"]:
            self.GetBeamInterruptions()
            for i in xrange(len(self.jump_ranges["start"])):
                excluded += [i for i in np.arange(self.jump_ranges["start"][i], self.jump_ranges["stop"][i] + 1)]  # events around jumps
        excluded.sort()
        all_events = np.arange(0, maxevent)
        included = np.delete(all_events, excluded)
        return included

    def SetExcludeFirst(self, n):
        '''
        Sets how many events at the very beginning of the run should be
        excluded. if the argument is negative, it will be interpreted as
        time in minutes. For a positive argument it is interpreted as
        maximum event number.
        :param n:
        :return:
        '''
        if n >= 0:
            self.__SetExcludeFirst(nevents=n)
        else:
            self._SetExcludeFirstTime(seconds=(-1) * n * 60)

    def _SetPeakPos_high(self, high):
        if high > 0:
            self.cut_types["peakPos_high"] = high
            self.userCutTypes["peakPos_high"] = "peakPos<{high}".format(high=high)

    def _SetSpread_low(self, low):
        if low > 0:
            self.cut_types["spread_low"] = low
            self.userCutTypes["spread_low"] = "spread>{low}".format(low=low)

    def _SetAbsMedian_high(self, high):
        if high > 0:
            self.cut_types["absMedian_high"] = high
            self.userCutTypes["absMedian_high"] = "|median|<{high}".format(high=high)

    def _SetPedestalSigma(self, sigma=-1):
        if sigma > 0:
            self.userCutTypes["pedestalsigma"] = "PedSigma" + str(sigma)
            self.cut_types["pedestalsigma"] = sigma
        else:
            self.userCutTypes["pedestalsigma"] = ""
            self.cut_types["pedestalsigma"] = -1

    def GetEventRange(self):
        """
        Returns a the lowest and highest event numbers to consider in the analysis. This event-range cut is defined either in the Analysis config file or in the indvidual cut file.
        The returned object is a list, which is empty if no event-range cut is applied.
        :return: cut eventrange
        """
        return self.cut_types["EventRange"]

    def GetMinEvent(self):
        """
        Returns the smallest event number satisfying the cut conditions.
        :return:
        """
        if self.cut_types["EventRange"] != []:
            return self.cut_types["EventRange"][0]
        elif self.cut_types["ExcludeFirst"] > 0:
            return self.cut_types["ExcludeFirst"]
        else:
            return 0

    def GetNEvents(self):
        '''
        Returns the number of events satisfying the cut conditions.
        :return:
        '''
        totEvents = self.analysis.GetEventAtTime(-1)
        if self.cut_types["EventRange"] != []:
            return self.cut_types["EventRange"][1] - self.cut_types["EventRange"][0]
        elif self.cut_types["ExcludeFirst"] > 0:
            return totEvents - self.cut_types["ExcludeFirst"]
        else:
            return totEvents

    def GetMaxEvent(self):
        '''
        Returns the highest event number satisfying the cut conditions.
        :return:
        '''
        totEvents = self.analysis.GetEventAtTime(-1)
        if self.cut_types["EventRange"] != []:
            return self.cut_types["EventRange"][1]
        else:
            return totEvents

    def _SetExcludeFirstTime(self, seconds):
        event = self.analysis.GetEventAtTime(time_sec=seconds)
        self.__SetExcludeFirst(nevents=event)
        if seconds > 0:
            self.userCutTypes["ExcludeFirst"] = str(int(seconds) / 60) + "min+"

    def __SetExcludeFirst(self, nevents):
        if nevents > 0:
            self.userCutTypes["ExcludeFirst"] = str(int(nevents) / 1000) + "k+"
        else:
            self.userCutTypes["ExcludeFirst"] = ""
        self.cut_types["ExcludeFirst"] = nevents
        self.excludefirst = nevents

    def GenerateCutString(self, gen_PulserCut=True, gen_EventRange=True, gen_ExcludeFirst=True, setChannel=True):
        """
        Creates the cut string, which will be stored in self.cut. With the arguments set to False, different cut types can be deactivated in the cut string.
        :param gen_PulserCut:
        :param gen_EventRange:
        :param gen_ExcludeFirst:
        :return:
        """
        if self._checklist["GenerateCutString"]:
            self.LoadConfig()  # re-generate
        cutstring = self.cut

        # -- EVENT RANGE CUT --
        if self.cut_types["EventRange"] != [] and gen_EventRange:
            if cutstring != "":
                cutstring += "&&"
            cutstring += "(event_number<={maxevent}&&event_number>={minevent})".format(minevent=self.cut_types["EventRange"][0], maxevent=self.cut_types["EventRange"][1])
            self.userCutTypes["EventRange"] = "Evts.{min}k-{max}k".format(min=int(self.cut_types["EventRange"][0]) / 1000, max=int(self.cut_types["EventRange"][1]) / 1000)
            self.userCutTypes["ExcludeFirst"] = ""
        elif self.cut_types["ExcludeFirst"] > 0 and gen_ExcludeFirst:
            if cutstring != "":
                cutstring += "&&"
            cutstring += "event_number>={minevent}".format(minevent=self.cut_types["ExcludeFirst"])
            self.userCutTypes["ExcludeFirst"] = "Evts.{min}k+".format(min=int(self.cut_types["ExcludeFirst"]) / 1000)
            self.userCutTypes["EventRange"] = ""
        else:
            self.userCutTypes["EventRange"] = ""
            self.userCutTypes["ExcludeFirst"] = ""


        # -- PULSER CUT --
        if self.cut_types["noPulser"] in [0, 1] and gen_PulserCut:
            if cutstring != "": cutstring += "&&"
            if self.cut_types["noPulser"] == 1:
                cutstring += "!pulser"
                self.userCutTypes["noPulser"] = "!pulser"
            else:
                cutstring += "pulser"
                self.userCutTypes["noPulser"] = "pulser"
        else:
            self.userCutTypes["noPulser"] = ""

        # -- SATURATED CUT --
        if self.cut_types["notSaturated"]:
            if cutstring != "": cutstring += "&&"
            cutstring += "!is_saturated[{channel}]"
            self.userCutTypes["notSaturated"] = "!saturated"
        else:
            self.userCutTypes["notSaturated"] = ""

        # -- TRACK CUT --
        if self.cut_types["Tracks"]:
            if cutstring != "": cutstring += "&&"
            cutstring += "n_tracks"
            self.userCutTypes["Tracks"] = "Tracks"
        else:
            self.userCutTypes["Tracks"] = ""

        # -- PEAK POSITION CUT --
        if self.cut_types["peakPos_high"] > 0:
            if cutstring != "": cutstring += "&&"
            cutstring += "sig_time[{channel}]<{high}".format(channel=self.channel, high=int(self.cut_types["peakPos_high"]))
            self.userCutTypes["peakPos_high"] = "peakPos<{high}".format(high=int(self.cut_types["peakPos_high"]))
        else:
            self.userCutTypes["peakPos_high"] = ""

        # -- SPREAD LOW CUT --
        if self.cut_types["spread_low"] > 0:
            if cutstring != "": cutstring += "&&"
            cutstring += "sig_spread[{channel}]>{low}".format(channel=self.channel, low=int(self.cut_types["spread_low"]))
            self.userCutTypes["spread_low"] = "spread>{low}".format(low=int(self.cut_types["spread_low"]))
        else:
            self.userCutTypes["spread_low"] = ""

        # -- MEDIAN CUT --
        if self.cut_types["absMedian_high"] > 0:
            if cutstring != "": cutstring += "&&"
            cutstring += "abs(median[{channel}])<{high}".format(channel=self.channel, high=int(self.cut_types["absMedian_high"]))
            self.userCutTypes["absMedian_high"] = "|median|<{high}".format(high=int(self.cut_types["absMedian_high"]))
        else:
            self.userCutTypes["absMedian_high"] = ""

        # -- PEDESTAL SIGMA CUT --
        if self.cut_types["pedestalsigma"] > 0:
            if cutstring != "":
                cutstring += "&&"
            self._LoadPedestalData(cutstring=cutstring)
            sigma = self.pedestalSigma
            pedestalmean = self.pedestalFitMean
            refactor = self.cut_types["pedestalsigma"]
            pedestal_n_sigma_range = [pedestalmean - refactor * sigma, pedestalmean + refactor * sigma]
            cutstring += self.analysis.pedestalname + "[{channel}]>" + str(pedestal_n_sigma_range[0]) + "&&" + self.analysis.pedestalname + "[{channel}]<" + str(pedestal_n_sigma_range[1])
            self.userCutTypes["pedestalsigma"] = "PedSigma" + str(refactor)
        else:
            self.userCutTypes["pedestalsigma"] = ""

        # -- set the channel on the cuts --
        if setChannel:
            self.cut = cutstring
            self.cut = self.cut.format(channel=self.channel)

        # -- BEAM INTERRUPTION CUT --
        if self.cut_types["noBeamInter"] and self._checklist["GenerateCutString"]:
            self.__remove_beam_interruptions(justDoIt=True)
            self.userCutTypes["noBeamInter"] = "beamOn"
        elif self.cut_types["noBeamInter"]:
            self.__remove_beam_interruptions()
            self.userCutTypes["noBeamInter"] = "BeamOn"
        else:
            self.userCutTypes["noBeamInter"] = ""

        self._checklist["GenerateCutString"] = True
        self.__cutstring_settings = {
            "gen_PulserCut": gen_PulserCut,
            "gen_EventRange": gen_EventRange,
            "gen_ExcludeFirst": gen_ExcludeFirst
        }

    def generate_beaminterruption_cut(self):
        pass

    def _checkCutStringSettings(self, gen_PulserCut, gen_EventRange, gen_ExcludeFirst):
        if self.__cutstring_settings["gen_PulserCut"] == gen_PulserCut and self.__cutstring_settings["gen_EventRange"] == gen_EventRange \
                and self.__cutstring_settings["gen_ExcludeFirst"] == gen_ExcludeFirst:
            return True
        else:
            return False

    def _LoadPedestalData(self, cutstring):
        picklepath = "Configuration/Individual_Configs/PedestalPeak/{tc}_{run}_{ch}_PedestalPeak.pickle".format(tc=self.TESTCAMPAIGN, run=self.analysis.run.run_number, ch=self.channel)
        if not hasattr(self, "pedestalFitMean"):
            if os.path.exists(picklepath):
                # print "Loading pedestal peak fit data from pickle file: \n\t"+picklepath
                picklefile = open(picklepath, "rb")
                fitparameters = pickle.load(picklefile)
                picklefile.close()
            else:
                # do fit
                # pedestalhisto = self.analysis._ShowHisto(self.analysis.pedestaldefinition[self.channel], channel=self.channel,
                #                                          canvas=None, drawoption="", color=None, cut=cutstring, normalized=False,
                #                                          infoid="CutPedestalFit", drawruninfo=False, binning=1000, xmin=-500, xmax=500,savePlots=False, logy=True, gridx=True)
                self.analysis.run.tree.Draw((self.analysis.pedestaldefinition[self.channel] + ">>tmphisto(1000,-500,500)").format(channel=self.channel), (cutstring[:-2]).format(channel=self.channel))
                pedestalhisto = ROOT.gROOT.FindObject("tmphisto")
                ped_peakpos = pedestalhisto.GetBinCenter(pedestalhisto.GetMaximumBin())
                pedestalhisto.Fit("gaus", "", "", ped_peakpos - 10, ped_peakpos + 10)
                fitfunc = pedestalhisto.GetFunction("gaus")
                fitparameters = [fitfunc.GetParameter(0), fitfunc.GetParameter(1), fitfunc.GetParameter(2)]
                # save to file
                picklefile = open(picklepath, "wb")
                pickle.dump(fitparameters, picklefile)
                picklefile.close()
            self.pedestalFitMean = fitparameters[1]
            self.pedestalSigma = fitparameters[2]

    def find_beam_interruptions(self):
        """
        Looking for the beam interruptions
        :return: interrupt list
        """
        print 'Searching for beam interruptions...'
        binning = 100
        nbins = int(self.analysis.run.tree.GetEntries()) / binning
        rate = []
        for i in xrange(nbins):
            pulserevents = self.analysis.run.tree.Draw("1", "pulser", "", binning, i * binning)
            rate.append(1. * pulserevents / binning)
        mean_rate = mean(rate)
        interrupts = []
        last_rate = 0
        tup = [0, 0]
        fac = 2
        for i, value in enumerate(rate):
            if value > fac * mean_rate > last_rate:
                tup[0] = i * binning
            elif value < fac * mean_rate < last_rate:
                tup[1] = i * binning
                interrupts.append(tup)
                tup = [0, 0]
            last_rate = value
        self.jumps = interrupts
        self.__save_beaminterrupts()
        self.__create_jump_ranges()
        return interrupts

    def __save_beaminterrupts(self):
        # check if directories exist
        if not os.path.exists(self.beaminterruptions_folder):
            os.mkdir(self.beaminterruptions_folder)
        if not os.path.exists(self.beaminterruptions_folder + "/data"):
            os.mkdir(self.beaminterruptions_folder + "/data")

        # save jump list to file
        jumpfile = open(self.beaminterruptions_folder + "/data/{testcampaign}Run_{run}.pickle".format(testcampaign=self.TESTCAMPAIGN, run=self.analysis.run.run_number), "wb")
        pickle.dump(self.jumps, jumpfile)
        jumpfile.close()

    def __create_jump_ranges(self):
        if self.jump_ranges is None and len(self.jumps) > 0:
            start = []
            stop = []
            time_offset = self.analysis.run.GetTimeAtEvent(0)
            t_max = (self.analysis.run.GetTimeAtEvent(-1) - time_offset) / 1000.
            last_stop = 0
            for tup in self.jumps:
                t_start = (self.analysis.run.GetTimeAtEvent(tup[0]) - time_offset) / 1000.
                t_stop = (self.analysis.run.GetTimeAtEvent(tup[1]) - time_offset) / 1000.
                # add offsets from config file
                t_start -= -1 * self.excludeBeforeJump if t_start >= -1 * self.excludeBeforeJump else 0
                t_stop = t_stop + -1 * self.excludeAfterJump if t_stop + -1 * self.excludeAfterJump <= t_max else t_max
                if t_start < last_stop:
                    stop[-1] = self.analysis.GetEventAtTime(t_stop)
                    last_stop = t_stop
                    continue
                start.append(self.analysis.GetEventAtTime(t_start))
                stop.append(self.analysis.GetEventAtTime(t_stop))
                last_stop = t_stop

            self.jump_ranges = {"start": start,
                                "stop": stop}
        return self.jump_ranges

    def GetBeamInterruptions(self):
        """
        If beam interruption data exist in beaminterruptions/data/, it will load it in order to account for beam interruptions. The data is stored as a list of jumps, dumped into a pickle file.
        If no pickle file exists, it will perform a beam interruption analysis in order to identify the beam interruptions. The found interruptions are stored in a list at .jumps and dumped into
        a pickle file.
        :return: list of events where beam interruptions occures
        """
        if self.jump_ranges is None:
            picklepath = self.beaminterruptions_folder + "/data/{testcampaign}Run_{run}.pickle".format(testcampaign=self.TESTCAMPAIGN, run=self.analysis.run.run_number)
            if os.path.exists(picklepath):
                # print "Loading beam interruption data from pickle file: \n\t"+picklepath
                jumpfile = open(picklepath, "rb")
                self.jumps = pickle.load(jumpfile)
                self.__create_jump_ranges()
                jumpfile.close()
            else:
                print "No pickle file found at: ", picklepath, "\n .. analyzing beam interruptions.. "
                self.find_beam_interruptions()
        return self.jumps

    def GetCutFunctionDef(self):
        """
        Returns the cut function definition, which is of type string.
        It is used for applying the cut on event-by-event readout
        loops over a TTree.
        The cut function definition defines the constraints on the
        branches in the ROOT TTree.

        Example: (considering only the branches 'pulser' and
        'is_saturated')
            A possible cut function definition could be:
            'lambda pulser, is_saturated: not pulser and not is_saturated'
        Before the iteration over the TTree branches are executed, a
        boolean function is defined as:
            check = exec(cut_object.GetCutFunctionDef())
        The event selection is then based on this lambda function
        'check':
            for i in xrange(nentries):
                tree.GetEntry(i)
                signal = tree.signal
                pulser = tree.pulser
                saturated = tree.is_saturated
                if check(pulser, saturated):
                    someting.Fill(signal)

        Note: the cut on the event-basis has to be applied by the
        method .GetIncludedEvents(), which returns only the events
        satisfying the event cuts.
        :return:
        """
        defstring_ = "lambda pulser, is_saturated, n_tracks, fft_mean, INVfft_max, sig_time, sig_spread, median: "
        def_ = ""

        if self.cut_types["IndividualChCut"] != "":
            raw_input("WARNING: cut0 and cut3 cannot be applied on Tracking Data! Press Enter to Continue..")

        if self.cut_types["noPulser"] == 1:
            def_ += "not pulser"
        elif self.cut_types["noPulser"] == 0:
            def_ += "pulser"

        if self.cut_types["notSaturated"]:
            if def_ != "": def_ += " and "
            def_ += "not is_saturated"

        if self.cut_types["Tracks"]:
            if def_ != "": def_ += " and "
            def_ += "n_tracks"

        if self.cut_types["FFT"]:
            if def_ != "": def_ += " and "
            assert (False), "FFT cut not yet implemented in GetCutFunctionDef() method of Cut class. "
            # to do: FFT entry in _cutTypes should be dict and/or contain a TCutG instance

        if self.cut_types["peakPos_high"] > 0:
            if def_ != "": def_ += " and "
            def_ += "sig_time<{high}".format(high=int(self.cut_types["peakPos_high"]))

        if self.cut_types["spread_low"] > 0:
            if def_ != "": def_ += " and "
            def_ += "sig_spread>{low}".format(low=int(self.cut_types["spread_low"]))

        if self.cut_types["absMedian_high"] > 0:
            if def_ != "": def_ += " and "
            def_ += "abs(median)>{low}".format(low=int(self.cut_types["absMedian_high"]))

        return defstring_ + def_

    def __remove_beam_interruptions(self, justDoIt=False):
        """
        This adds the restrictions to the cut string such that beam interruptions are excluded each time the cut is applied.
        :return: cut
        """
        if not self._checklist["RemoveBeamInterruptions"] or justDoIt:
            self.GetBeamInterruptions()

            njumps = len(self.jump_ranges["start"])
            cut_string = ''
            for i in xrange(njumps):
                string = "!(event_number<={upper}&&event_number>={lower})".format(upper=self.jump_ranges["stop"][i], lower=self.jump_ranges["start"][i])
                if self.cut != "":
                    self.cut += "&&"
                self.cut += string
                # new seperate strings
                if cut_string != '':
                    cut_string += '&&'
                cut_string += string
            self.cut_strings['beam_interruptions'] = cut_string
            self._checklist["RemoveBeamInterruptions"] = True

        return self.cut

    def AddCutString(self, cutstring):
        pass

    def GetCut(self, setChannel=True, gen_PulserCut=True, gen_EventRange=True, gen_ExcludeFirst=True, ):
        '''
        Returns the cut string.
        If needed, it will re-generate the cut string.
        :param gen_PulserCut:
        :param gen_EventRange:
        :param gen_ExcludeFirst:
        :return:
        '''
        # channel = self.channel
        if not self._checkCutStringSettings(gen_PulserCut, gen_EventRange, gen_ExcludeFirst):
            self.GenerateCutString(gen_PulserCut, gen_EventRange, gen_ExcludeFirst, setChannel=setChannel)
        return self.cut

    def GetUserCutString(self):
        '''
        Returns a short, more user-friendly cut string, which can be
        used to display the cut configuration as terminal prompt or
        inside a canvas.
        :return:
        '''
        string_ = ""
        for type_ in self.userCutTypes.keys():
            if self.userCutTypes[type_] != "":
                string_ += self.userCutTypes[type_] + ", "
        if string_ != "": string_ = string_[:-2]
        return string_

    def ShowCuts(self):
        pass

    def SetFFTCut(self):
        pass
